<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content='IE=edge;chrome=1'/> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=canonical href=https://kevinjalbert.com/find-and-bury-dead-code/> <title>Find and Bury Dead Code | Kevin Jalbert</title> <meta name=description content="Dead code has no reason to be in a project. Dead code wastes a developer’s time and energy. Going from this it makes sense to remove the dead code and put it rest with a delete keystroke. The main ..."/> <meta name=keywords content="software, software quality, ruby"/> <meta name=datePublished content="2017-02-26 00:00:00 UTC"/> <meta property="og:article:published_time" content="2017-02-26 00:00:00 UTC"/> <meta name=author content="Kevin Jalbert"/> <meta property="og:article:author" content="2017-02-26 00:00:00 UTC"/> <meta name=url content="https://kevinjalbert.com/find-and-bury-dead-code/"/> <meta property="og:url" content="https://kevinjalbert.com/find-and-bury-dead-code/"/> <meta name=site content="Kevin Jalbert"/> <meta property="og:site_name" content="Kevin Jalbert"/> <meta name="twitter:card" content=summary_large_image /> <meta name="twitter:creator" content="@kevinjalbert"/> <meta name="twitter:description" content="Dead code has no reason to be in a project. Dead code wastes a developer’s time and energy. Going from this it makes sense to remove the dead code and put it rest with a delete keystroke. The main problem is how to identify dead code in a living project?"/> <meta name="twitter:image:src" content="https://kevinjalbert.com/images/kevin-jalbert.jpg"/> <meta name="twitter:site" content="Kevin Jalbert"/> <meta name="twitter:title" content="Find and Bury Dead Code"/> <meta property="og:description" content="Dead code has no reason to be in a project. Dead code wastes a developer’s time and energy. Going from this it makes sense to remove the dead code and put it rest with a delete keystroke. The main problem is how to identify dead code in a living project?"/> <meta property="og:image" content="https://kevinjalbert.com/images/kevin-jalbert.jpg"/> <meta property="og:title" content="Find and Bury Dead Code"/> <script type="application/ld+json">
    {
       "@context": "http://schema.org",
       "@type": "BlogPosting",
       "headline": "Find and Bury Dead Code",
       "keywords": "software, software quality, ruby",
       "url": "https://kevinjalbert.com/find-and-bury-dead-code/",
       "datePublished": "2017-02-26 00:00:00 UTC",
       "dateModified": "2017-02-26 00:00:00 UTC",
       "author": {
         "@type": "Person",
         "name": "Kevin Jalbert",
         "sameAs": [
           "https://twitter.com/kevinjalbert",
           "https://github.com/kevinjalbert",
           "https://keybase.io/kevinjalbert",
           "https://reddit.com/user/kevinjalbert"
         ]
       },
       "mainEntityOfPage": {
          "@type": "WebPage",
         "@id": "https://kevinjalbert.com/find-and-bury-dead-code/"
       }
    }
  </script> <link href="/stylesheets/app.css" rel=stylesheet /> <link rel=alternate type="application/atom+xml" title="Articles | Kevin Jalbert" href="/feed.xml"/> </head> <div class=container> <div class=header> <div class="col-xs-12 col-sm-7 navigation"> <a class=banner href="/">Kevin Jalbert</a> <a href="/about/">About</a> <a href="/now/">Now</a> </div> <div class="col-xs-12 col-sm-5 search-component"> <input placeholder=Search class="search ui-autocomplete-input ui-corner-all" autocomplete=on> </div> </div> </div> <body> <div class="container content article"> <div class=row> <div class=col-md-12> <h1 class=article__title><p>Find and Bury Dead Code</p> </h1> <div class="row article__meta-info"> <div class="col-xs-4 col-md-4"> <div class=article__date>February 26, 2017 </div> </div> <div class="col-xs-4 col-md-4"> <div class=article__read-time>6 min read</div> </div> <div class="col-xs-4 col-md-4"> <div class=article__comments> <a href="https://kevinjalbert.com/find-and-bury-dead-code/#disqus_thread">0 Comments</a> </div> </div> </div> <div class="row article__meta-tags"> <div class="col-xs-12 col-md-12"> <div class=article__tags> <a href="/tags/software/">software</a> <a href="/tags/software-quality/">software quality</a> <a href="/tags/ruby/">ruby</a> </div> </div> </div> <div class=article__separator></div> <div class=newsletter__form> <div class="panel panel-default"> <div class=panel-heading> <h4 class="panel-title accordion-toggle collapsed" data-toggle=collapse data-parent="#accordion" href="#newsletterFormCollapse"> Signup for my Newsletter </h4> </div> <div id=newsletterFormCollapse class="panel-collapse collapse"> <div class=panel-body> <link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel=stylesheet> <style>
              #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
              /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
                 We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
        </style> <div id=mc_embed_signup> <form action="//kevinjalbert.us14.list-manage.com/subscribe/post?u=fe02783eec556cfc2893fe174&amp;id=aecd14f8e6" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate> <div id=mc_embed_signup_scroll> <input type=email value="" name=EMAIL class=email id=mce-EMAIL placeholder="email address" required> <div style="position: absolute; left: -5000px;" aria-hidden=true><input name=b_fe02783eec556cfc2893fe174_aecd14f8e6 tabindex=-1 value=""></div> <div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div> </div> </form> </div> </div> </div> </div> </div> <p>Dead code has no reason to be in a project. When you know it’s there, it simply nags at you to be removed. Sometimes you aren’t even sure that you have dead code. It might just be the case that every line of your codebase is being executed, which if true is great! The other scenario is that there is some dead code wasting developers’ time as they maintain it and work with it. Going from this it makes sense to remove the dead code and put it rest with a delete keystroke. The main problem is how to identify dead code in a living project?</p> <h1>Finding Dead Code</h1> <p>In smaller projects, it’s possible to simply see and know what is dead code just from the usage and familiarity you might have with the project. Within larger projects, identifying dead code is not as straight forward. Luckily, we have tools and systems that can aid us. For the most part, we will be looking at this problem from a dynamic language perspective, primarily Ruby.</p> <h2>Static Analysis Tools</h2> <p>Static analysis tools do not run the application and only examine the source code itself. A general property of these tools is the speed and ease of use, although they come at a price of precision (i.e., missing and incorrect results). I’ll will first present a Ruby specific tool called <strong><em>debride</em></strong> and then a language agnostic tool called <strong><em>unused</em></strong>:</p> <p><a href="https://github.com/seattlerb/debride"><strong><em>debride</em></strong></a> &ndash; This tool analyzes your Ruby source code and detects uncalled or dead methods. It knows of Ruby on Rails method definitions, as they are not defined in your codebase. In addition, you can provide a whitelist of methods that you know should not be flagged by the tool. This is a specific tool that is tailored to work on Ruby and Rails projects.</p> <p><a href="https://github.com/joshuaclayton/unused"><strong><em>unused</em></strong></a> &ndash; This tool is language agnostic. It first requires a <a href="http://ctags.sourceforge.net/"><em>ctags</em></a> file for your project, containing all the project class/method definitions and their locations. With this, <em>unused</em> is able to scan through your project using <a href="https://github.com/ggreer/the_silver_searcher"><em>ag</em></a> for statements calling these definitions. Throughout the search, if no usage of the class/method definition is found, then that code is probably unused. In addition, there is a configuration file for further customization to reduce false positives.</p> <p>With both of these static analysis tools, there is a precision issue of whether or not the detected code is actually used during the execution of your project. This does not strum up immediate confidence in the results and often requires deeper investigation. Another large concern when dealing with dynamic language is class/method defined at runtime or methods that are invoked via meta programming.</p> <h2>Dynamic Analysis Tools</h2> <p>Dynamic analysis tools, unlike their static counterparts, actually need to run the source code. A general property of these tools is that they provide richer and more accurate results, although at the cost of performance (i.e., slower due to measuring at runtime). I’ll present first a Ruby specific tool called <strong><em>coverband</em></strong> and then a language agnostic tool called <strong><em>scythe</em></strong>:</p> <p><a href="https://github.com/danmayer/coverband"><strong><em>coverband</em></strong></a> &ndash; The approach that <em>coverband</em> uses could be applied to other languages, although it is a Ruby specific implementation. This tool borrows the results format of test suite coverage (i.e., how much code is exercised by your test suite), however it measures code coverage during the runtime of your application. A nice use case that <em>coverband</em> accounts for is multiple instances of your application, it uses a <em>redis</em> instance to hold the coverage results. There is some performance cost for using <em>coverband</em>, as it records each line executed. If you are measuring a web application, the tool allows you to instrument a percentage of your requests. The coverage information keeps tracks of the number of times each line is hit, and this can indicate hot spots in your application.</p> <p><a href="https://github.com/michaelfeathers/scythe"><strong><em>scythe</em></strong></a> — The approach that <em>scythe</em> uses is language agnostic. The basic idea is to place probes within your source code that when triggered, record the date and time to a file matching the probe’s name. At its heart, <em>scythe</em> is a command-line utility that reports on these files, giving you an indication of how long since the probe was last called. Currently, there are probe implementations for Java, Python and Ruby. Due to the simple contract (files which are updated when probes are triggered), it is not difficult to make <em>scythe</em> work for other languages. The overhead using the probes is minimal and can be placed anywhere in your source code. Unfortunately, we have to use a manual process in placing and inspecting the probes.</p> <p>Both of the above tools took different approaches for dead code identification. In either case, the underlying source code must be executed, and usually there is setup required for the tool to work in conjunction with the running application.</p> <h1>Burying the Dead</h1> <p>Now that we know that there is a class of tools for detecting dead code, the next set of questions revolve around removing the dead code.</p> <blockquote> <p>The tool indicates this code is dead. Can we remove it?</p> </blockquote> <p>Recall that static vs. dynamic analysis can inspire different levels of confidence. Tools like <em>scythe</em> or <em>coverband</em> actually determine whether the source code in question was executed in a real environment. The problem is whether or not the tool collected enough data during execution to ensure the code in question could have been ran. It is hard to know whether or not flagged dead code is just code that is rarely ran, but still alive.</p> <p>With sufficient time, it should be possible to make the decision to remove the dead code. As with any change, be observant to any signals that could indicate that the removal was of live code. Given the complex scope of usage, it can be difficult to detect dead code if there are third parties using your codebase. A side bonus of removing dead code, is that any associated tests can be removed &ndash; effectively speeding up your test suite.</p> <h1>Moving on</h1> <p>By removing dead code the scale of the source code shrinks ever so slightly. There is little to no point in having extra code in your project if it does not add value. There is possible arguments that if it works, there is no need to change it. I would counter that by saying that keeping dead code around is lugging around a mental burden that developers have to deal with. Dead code wastes a developer’s time and energy. Imagine having to upgrade a dependency and making changes in dead code &ndash; what a waste.</p> <blockquote> <p>Dead code wastes a developer’s time and energy.</p> </blockquote> <p>Do be aware that there is some initial time investment in getting a system in place and learning how to identify dead code in your specific projects. In the long run, however, it is bound to save headaches in a long running project.</p> <hr> <h1>TL;DR</h1> <ul> <li>Dead code is code that is never exercised during the execution of the application.</li> <li>Two types of tools exist for finding dead code: Static and Dynamic analysis tools <ul> <li>Dead code static analysis tools observe the source code and attempt to deduce methods that are never used.</li> <li>Dead code dynamic analysis tools instrument the running state of the source code and record what is executed.</li> </ul></li> <li>Only remove dead code when you are confident that it is no longer used (deeper investigation and/or let dynamic analysis tools run for longer).</li> <li>Less code relieves mental burden, and reduces time wasted while working in a codebase.</li> </ul> <div class=article__comments-button><button type=button class="btn btn-default show-comments">Click to Disqus</button></div> <div id=disqus_thread></div> </div> </div> </div> <script>
//<![CDATA[
    var disqus_shortname = 'kevinjalbert';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
//]]>
</script> </body> <div class="col-md-12 footer__copywrite"> &copy; 2017 Kevin Jalbert </div> </html> <script src="/javascripts/app.js"></script> <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-16620161-5']);
    _gaq.push(['_trackPageview']);

    setTimeout(function() {
      window.onscroll = function() {
        window.onscroll = null; // Only track the event once
        _gaq.push(['_trackEvent', 'scroll', 'read']);
      }
    }, 5000);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>