<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content='IE=edge;chrome=1'/> <meta name=viewport content="width=device-width, initial-scale=1"> <script>addEventListener('error', window.__e=function f(e){f.q=f.q||[];f.q.push(e)});</script> <link rel=canonical href=https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/> <title>GraphQL Persisted Queries with HTTP Caching [Part 1] | Kevin Jalbert</title> <meta name=description content="This is the first of four parts on GraphQL Persisted Queries with HTTP Caching. We start by describing some problems with GraphQL due to its flexibility, and how we can solve the issues with persis..."/> <meta name=keywords content="graphql, rails, express, http caching"/> <meta name=datePublished content="2018-07-15 00:00:00 UTC"/> <meta property="og:article:published_time" content="2018-07-15 00:00:00 UTC"/> <meta name=author content="Kevin Jalbert"/> <meta property="og:article:author" content="2018-07-15 00:00:00 UTC"/> <meta name=url content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/"/> <meta property="og:url" content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/"/> <meta name=site content="Kevin Jalbert"/> <meta property="og:site_name" content="Kevin Jalbert"/> <meta name="twitter:card" content=summary_large_image /> <meta name="twitter:creator" content="@kevinjalbert"/> <meta name="twitter:description" content="This is the first of four parts on GraphQL Persisted Queries with HTTP Caching. We start by describing some problems with GraphQL due to its flexibility, and how we can solve the issues with persisted queries."/> <meta name="twitter:image:src" content="https://kevinjalbert.com/images/2018-07-15-graphql-persisted-queries-with-http-caching-part-1/post-query.png"/> <meta name="twitter:site" content="Kevin Jalbert"/> <meta name="twitter:title" content="GraphQL Persisted Queries with HTTP Caching [Part 1]"/> <meta property="og:description" content="This is the first of four parts on GraphQL Persisted Queries with HTTP Caching. We start by describing some problems with GraphQL due to its flexibility, and how we can solve the issues with persisted queries."/> <meta property="og:image" content="https://kevinjalbert.com/images/2018-07-15-graphql-persisted-queries-with-http-caching-part-1/post-query.png"/> <meta property="og:title" content="GraphQL Persisted Queries with HTTP Caching [Part 1]"/> <script type="application/ld+json">
    {
       "@context": "http://schema.org",
       "@type": "BlogPosting",
       "headline": "GraphQL Persisted Queries with HTTP Caching [Part 1]",
       "keywords": "graphql, rails, express, http caching",
       "url": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/",
       "datePublished": "2018-07-15 00:00:00 UTC",
       "dateModified": "2018-07-15 00:00:00 UTC",
       "author": {
         "@type": "Person",
         "name": "Kevin Jalbert",
         "sameAs": [
           "https://twitter.com/kevinjalbert",
           "https://github.com/kevinjalbert",
           "https://keybase.io/kevinjalbert",
           "https://reddit.com/user/kevinjalbert"
         ]
       },
       "mainEntityOfPage": {
          "@type": "WebPage",
         "@id": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/"
       }
    }
  </script> <link href="/stylesheets/app.css" rel=stylesheet /> <link rel=alternate type="application/atom+xml" title="Articles | Kevin Jalbert" href="/feed.xml"/> <script async src="/vendor/analytics/index.js"></script> <script async src="https://www.google-analytics.com/analytics.js"></script> </head> <div class=container> <div class=header> <div class="col-xs-12 col-sm-7 navigation"> <a class=banner href="/">Kevin Jalbert</a> <a href="/about/">About</a> <a href="/now/">Now</a> <a href="https://github.com/kevinjalbert/ama/blob/master/README.md">AMA</a> </div> <div class="col-xs-12 col-sm-5 search-component"> <input placeholder=Search class="search ui-autocomplete-input ui-corner-all" autocomplete=on> </div> </div> </div> <body> <div class="container content article"> <div class=row> <div class=col-md-12> <h1 class=article__title><p>GraphQL Persisted Queries with HTTP Caching [Part 1]</p> </h1> <div class="row article__meta-info"> <div class="col-xs-4 col-md-4"> <div class="article__date entry-date">July 15, 2018 </div> </div> <div class="col-xs-4 col-md-4"> <div class=article__read-time>5 min read</div> </div> <div class="col-xs-4 col-md-4"> <div class=article__comments> <a href="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-1/#disqus_thread">0 Comments</a> </div> </div> </div> <div class="row article__meta-tags"> <div class="col-xs-12 col-md-12"> <div class=article__tags> <a href="/tags/graphql/">graphql</a> <a href="/tags/rails/">rails</a> <a href="/tags/express/">express</a> <a href="/tags/http-caching/">http caching</a> </div> </div> </div> <img src=/images/2018-07-15-graphql-persisted-queries-with-http-caching-part-1/post-query.png> <i><p>Generated with <a href="https://carbon.now.sh/">Carbon.now.sh</a></p> </i> <div class=article__separator></div> <p>GraphQL is a fast growing API specification, with aims of replacing REST APIs. A GraphQL server describes the data capabilities through the use of a type system and resolvers. A client is able to send a descriptive GraphQL query of what they want. The structure of the response then matches the query, providing a predictable result. There are many benefits to GraphQL servers and clients, to which I am not going to cover here as there is plenty of material on the Internet talking about those.</p> <p>This four-part blog post series is specifically covering the topic of <em>GraphQL Persisted Queries</em>. A persisted query is a slight modification to the GraphQL specification that allows for better performance and security, at the cost of less flexibility. I will cover a bit of history regarding persisted GraphQL queries, along with the problems it solves. We will look at how to implement persisted queries in Rails and Express. As an extension to persisted queries, we will look at how to adapt them to take advantage of HTTP caching.</p> <h1>Problems with GraphQL</h1> <p>GraphQL presents a flexible endpoint to which clients can send queries, however, this flexibility comes at a cost. The following three concerns are specifically targeting performance and security:</p> <ul> <li>Queries could be large (i.e., data being sent) when compared to a standard REST endpoint</li> <li>Queries could be inefficiently constructed (i.e., resource expensive)</li> <li>Queries could be maliciously constructed (i.e., circular in nature)</li> </ul> <p>As a consumer of a GraphQL API, it possible to construct <em>any query</em> for the server to process. You can hope that the consumers are doing their best to create good queries, but in a public API that might not be the case. You might have ill-informed users creating very expensive queries, or even a bad actor trying to timeout or cripple your server by sending deeply cyclical queries.</p> <p>There are several ways to mitigate these issues, as further outlined by <a href="https://twitter.com/mxstbr">Max Stoiber&rsquo;s</a> article on <a href="https://dev-blog.apollodata.com/securing-your-graphql-api-from-malicious-queries-16130a324a6b"><em>Securing Your GraphQL API from Malicious Queries</em></a>. In particular: - <em>Depth Limiting</em>: Rejecting queries which are too deeply nested - <em>Amount Limiting</em>: Rejecting queries which ask for too much information (i.e., via pagination arguments) - <em>Query Cost Analysis</em>: Rejecting queries which are too expensive (by assigning complexity values to fields) - <em>Query Whitelisting</em>: Rejecting queries that are not whitelisted</p> <p>I would like to also add <em>Time Limiting</em>, which would reject queries that take too long to resolve. <em>Query Whitelisting</em> is only applicable for private APIs, but otherwise, these are all good approaches for preventing malicious or expensive queries from hitting your API. As per the topic we are covering, we&rsquo;ll focus on Query Whitelisting (otherwise known as Persisted Queries).</p> <h1>Persisted Queries</h1> <p><a href="https://twitter.com/leeb/status/829434814402945026">Facebook has been using persisted queries since 2013</a>, and comes highly recommended for production usage from them. The essence of a persisted query is that the query is <em>persisted</em> on the server&rsquo;s side and that a client can <em>reference</em> it using some unique identifier. A great primer on persisted queries can be found on <a href="https://dev-blog.apollodata.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5">Apollo&rsquo;s blog article for this topic</a>.</p> <p>For the sake of completeness, I want to demonstrate a scenario where persisted queries shine.</p> <p>A client sends the following query to the server:</p> <div class=highlight><pre class="highlight graphql"><code><span class="k">query</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">company</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">name</span><span class="w">
    </span><span class="n">consoles</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">name</span><span class="w">
      </span><span class="n">releaseYear</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div> <p>No problems so far! Now a bad actor sends the following query:</p> <div class=highlight><pre class="highlight graphql"><code><span class="k">query</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">company</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">consoles</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">company</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">consoles</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="n">company</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="n">consoles</span><span class="w"> </span><span class="p">{</span><span class="w">
              </span><span class="n">name</span><span class="w">
              </span><span class="c"># ... continues nesting till happy with the damage</span><span class="w">
            </span><span class="p">}</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div> <p>The server evaluating this query can experience performance or stability issues due to the deep nesting and complex nature of the query. Going forward, we will make some assumptions about our API: - We control both the server and the clients (i.e., web/mobile clients) - We don&rsquo;t expose a public API (it is accessible, but it isn&rsquo;t promoted for external usage) - The data being returned from the queries is not personalized</p> <p>In our specific case, we can use persisted queries to remedy the issue of malicious users sending bad queries to our API. In addition, we will also gain some performance benefits (i.e., reducing the request&rsquo;s network size).</p> <ol> <li>Persist the query on the server and make note of the signature of the query (i.e., a hash of the query)</li> <li>The client sends the query signature to the server, along with any query variables</li> <li>Using the signature, the server looks up the matching query from a set of persisted queries</li> <li>The server executes the query and returns the data</li> </ol> <p>That sounds great, but how can we go about implementing this? As previously mentioned, persisted queries are not part of the official specification. There are many implementations that exist, as well as some tooling for supporting persisted queries. In my experience at the time of writing this, there wasn&rsquo;t a standard way to implement persisted queries.</p> <p>I want to stress the following: <strong>Persisted Queries only work if you control the server and the client</strong>. In theory, you could use persisted queries on public APIs, although the <em>security</em> gains are not present. I do want to mention that <a href="https://dev-blog.apollodata.com/improve-graphql-performance-with-automatic-persisted-queries-c31d27b8e6ea">Automatic Persisted Queries</a> is one way which uses the concept of persisted queries solely for performance gains.</p> <h1>Implementing GraphQL Persisted Queries with HTTP Caching</h1> <p>For the sake of brevity and focus, this series will focus on the following platforms:</p> <ul> <li><a href="https://github.com/facebook/react/">React</a> with <a href="https://github.com/apollographql/apollo-client">Apollo Client</a></li> <li><a href="https://github.com/expressjs/express">Express</a> with <a href="https://github.com/prismagraphql/graphql-yoga">GraphQL Yoga</a></li> <li><a href="https://github.com/rails/rails">Rails</a> with <a href="https://github.com/rmosolgo/graphql-ruby">GraphQL Ruby</a></li> </ul> <p><a href="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-2/">Part two</a> will cover the following sections:</p> <ol> <li>Setup Express Server</li> <li>Setup React Application</li> <li>Refactor React Application to use Persisted Queries</li> <li>Extract GraphQL Queries from Client</li> <li>Refactor Express Server to use Persisted Queries</li> </ol> <p><a href="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/">Part three</a> will cover the following sections:</p> <ol> <li>Setup Rails Server</li> <li>Synchronize GraphQL Queries to Rails Server</li> <li>Refactor Rails Server to use Persisted Queries</li> </ol> <p>Part four will cover the following sections:</p> <ol> <li>Add HTTP Caching to React Application</li> <li>Add HTTP Caching to Express Server</li> <li>Add HTTP Caching to Rails Server</li> <li>Alternative Caching with Gateways</li> </ol> <div class=newsletter__form> <div class="panel panel-default"> <div class=panel-heading> <h4 class="panel-title accordion-toggle collapsed" data-toggle=collapse data-parent="#accordion" href="#newsletterFormCollapse"> Signup for my Newsletter </h4> </div> <div id=newsletterFormCollapse class="panel-collapse collapse"> <div class=panel-body> <link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel=stylesheet> <style>
              #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
              /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
                 We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
        </style> <div id=mc_embed_signup> <form action="//kevinjalbert.us14.list-manage.com/subscribe/post?u=fe02783eec556cfc2893fe174&amp;id=aecd14f8e6" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate> <div id=mc_embed_signup_scroll> <input type=email value="" name=EMAIL class=email id=mce-EMAIL placeholder="email address" required> <div style="position: absolute; left: -5000px;" aria-hidden=true><input name=b_fe02783eec556cfc2893fe174_aecd14f8e6 tabindex=-1 value=""></div> <div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div> </div> </form> </div> </div> </div> </div> </div> <div class=article__comments-button><button type=button class="btn btn-default show-comments">Click to Disqus</button></div> <div id=disqus_thread></div> </div> </div> </div> <script>
//<![CDATA[
    var disqus_shortname = 'kevinjalbert';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
//]]>
</script> </body> <div class="col-md-12 footer__copywrite"> &copy; 2018 Kevin Jalbert </div> </html> <script src="/javascripts/app.js"></script>