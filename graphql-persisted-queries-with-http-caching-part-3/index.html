<!DOCTYPE html> <html lang=en> <head> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SZ2C67981H"></script> <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-SZ2C67981H');
    </script> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content='IE=edge;chrome=1'/> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=canonical href=https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/> <title>GraphQL Persisted Queries with HTTP Caching [Part 3] | Kevin Jalbert</title> <meta name=description content="This is the third of four parts on GraphQL Persisted Queries with HTTP Caching. We continue our journey with creating a Rails GraphQL API, synchronizing queries to it, and adapting it to use persis..."/> <meta name=keywords content="graphql, rails, express, http caching"/> <meta name=datePublished content="2018-07-17 00:00:00 UTC"/> <meta property="og:article:published_time" content="2018-07-17 00:00:00 UTC"/> <meta name=author content="Kevin Jalbert"/> <meta property="og:article:author" content="2018-07-17 00:00:00 UTC"/> <meta name=url content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/"/> <meta property="og:url" content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/"/> <meta name=site content="Kevin Jalbert"/> <meta property="og:site_name" content="Kevin Jalbert"/> <meta name="twitter:card" content=summary_large_image /> <meta name="twitter:creator" content="@kevinjalbert"/> <meta name="twitter:description" content="This is the third of four parts on GraphQL Persisted Queries with HTTP Caching. We continue our journey with creating a Rails GraphQL API, synchronizing queries to it, and adapting it to use persisted queries."/> <meta name="twitter:image:src" content="https://kevinjalbert.com/images/2018-07-17-graphql-persisted-queries-with-http-caching-part-3/post-query.png"/> <meta name="twitter:site" content="Kevin Jalbert"/> <meta name="twitter:title" content="GraphQL Persisted Queries with HTTP Caching [Part 3]"/> <meta property="og:description" content="This is the third of four parts on GraphQL Persisted Queries with HTTP Caching. We continue our journey with creating a Rails GraphQL API, synchronizing queries to it, and adapting it to use persisted queries."/> <meta property="og:image" content="https://kevinjalbert.com/images/2018-07-17-graphql-persisted-queries-with-http-caching-part-3/post-query.png"/> <meta property="og:title" content="GraphQL Persisted Queries with HTTP Caching [Part 3]"/> <script type="application/ld+json">
    {
       "@context": "http://schema.org",
       "@type": "BlogPosting",
       "headline": "GraphQL Persisted Queries with HTTP Caching [Part 3]",
       "keywords": "graphql, rails, express, http caching",
       "url": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/",
       "datePublished": "2018-07-17 00:00:00 UTC",
       "dateModified": "2018-07-17 00:00:00 UTC",
       "author": {
         "@type": "Person",
         "name": "Kevin Jalbert",
         "sameAs": [
           "https://twitter.com/kevinjalbert",
           "https://github.com/kevinjalbert",
           "https://keybase.io/kevinjalbert",
           "https://reddit.com/user/kevinjalbert"
         ]
       },
       "mainEntityOfPage": {
          "@type": "WebPage",
         "@id": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/"
       }
    }
  </script> <link href="/stylesheets/app.css" rel=stylesheet /> <link rel=alternate type="application/atom+xml" title="Articles | Kevin Jalbert" href="/feed.xml"/> </head> <div class=container> <div class=header> <div class="col-xs-12 col-sm-7 navigation"> <a class=banner href="/">Kevin Jalbert</a> <a href="/about/">About</a> <a href="/now/">Now</a> <a href="/uses/">Uses</a> <a href="https://github.com/kevinjalbert/ama/blob/master/README.md">AMA</a> </div> <div class="col-xs-12 col-sm-5 search-component"> <input placeholder=Search class="search ui-autocomplete-input ui-corner-all" autocomplete=on> </div> </div> </div> <body> <div class="container content article"> <div class=row> <div class=col-md-12> <h1 class=article__title><p>GraphQL Persisted Queries with HTTP Caching [Part 3]</p> </h1> <div class="row article__meta-info"> <div class="col-xs-4 col-md-4"> <div class="article__date entry-date">July 17, 2018 </div> </div> <div class="col-xs-4 col-md-4"> <div class=article__read-time>3 min read</div> </div> <div class="col-xs-4 col-md-4"> <div class=article__comments> <a href="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-3/#disqus_thread">0 Comments</a> </div> </div> </div> <div class="row article__meta-tags"> <div class="col-xs-12 col-md-12"> <div class=article__tags> <a href="/tags/express/">express</a> <a href="/tags/graphql/">graphql</a> <a href="/tags/http-caching/">http caching</a> <a href="/tags/rails/">rails</a> </div> </div> </div> <img src=/images/2018-07-17-graphql-persisted-queries-with-http-caching-part-3/post-query.png> <i><p>Generated with <a href="https://carbon.now.sh/">Carbon.now.sh</a></p> </i> <div class=article__separator></div> <div class=newsletter__form> <div class="panel panel-default"> <div class=panel-heading> <h4 class="panel-title accordion-toggle collapsed" data-toggle=collapse data-parent="#accordion" href="#newsletterFormCollapse"> If you enjoy this, consider subscribing to my newsletter </h4> </div> <div id=newsletterFormCollapse class="panel-collapse collapse"> <div class=panel-body> <p style="text-align: center">I aim to publish one article a month</p> <link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel=stylesheet> <style>
              #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
              /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
                 We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
        </style> <div id=mc_embed_signup> <form action="//kevinjalbert.us14.list-manage.com/subscribe/post?u=fe02783eec556cfc2893fe174&amp;id=aecd14f8e6" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate> <div id=mc_embed_signup_scroll> <input type=email value="" name=EMAIL class=email id=mce-EMAIL placeholder="E-mail address" required> <div style="position: absolute; left: -5000px;" aria-hidden=true><input name=b_fe02783eec556cfc2893fe174_aecd14f8e6 tabindex=-1 value=""></div> <div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div> </div> </form> </div> </div> </div> </div> </div> <p>This is the third part of a four-part series on GraphQL Pesisted Queries with HTTP Caching. As a recap of <a href="/graphql-persisted-queries-with-http-caching-part-2/">part two</a>, we created an Express server and React application, both using persisted queries.</p> <p>In part three we will cover the following topics:</p> <ol> <li>Setup Rails Server</li> <li>Synchronize GraphQL Queries to Rails Server</li> <li>Refactor Rails Server to use Persisted Queries</li> </ol> <h1>Setup Rails Server</h1> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/5f78ac6dd2840a8690d82e4b50a752471332c8c2">GitHub</a></p> </blockquote> <p>We&rsquo;ll create a basic Rails server that uses <a href="https://github.com/rmosolgo/graphql-ruby"><code>graphql-ruby</code></a>. We will gloss over the busy work of setting up the models, database, and GraphQL types. First, we have our route defined that will accept <code>POST</code> requests to <code>/graphql</code> and passes them to our controller.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># config/routes.rb</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="n">post</span> <span class="s2">"/graphql"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"graphql#execute"</span>
<span class="k">end</span>
</code></pre></div> <p>The controller then extracts the variables, query, and operation name from the request&rsquo;s parameters. All this information is then executed against the GraphQL schema.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># app/controllers/graphql_controller.rb</span>
<span class="k">class</span> <span class="nc">GraphqlController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">execute</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">ensure_hash</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:variables</span><span class="p">])</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:query</span><span class="p">]</span>
    <span class="n">operation_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:operationName</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="no">RailsGraphqlSchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="ss">variables: </span><span class="n">variables</span><span class="p">,</span> <span class="ss">operation_name: </span><span class="n">operation_name</span><span class="p">)</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="n">result</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">ensure_hash</span><span class="p">(</span><span class="n">ambiguous_param</span><span class="p">)</span>
    <span class="c1"># ... Generated code provided by graphql-ruby's graphql:install</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <h1>Synchronize GraphQL Queries to Rails Server</h1> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/9f72e132f88e6f551e07700fd35539890d9e2a44">GitHub</a></p> </blockquote> <p>To accommodate persisted queries, we will have to <em>synchronize</em> the queries from our React application to our Rails server. Fortunately, <code>persistgraphql-signature-sync</code> (our script from earlier to extract queries) does this already.</p> <blockquote> <p>It is possible to sync the persisted queries to a specified endpoint. The endpoint needs to accept a POST request with body parameters of query and signature.</p> </blockquote> <p>We will need to do a few things to support this new synchronization endpoint.</p> <p>Let&rsquo;s create a new <code>PersistedQuery</code> model and migration:</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># app/models/persisted_query.rb</span>
<span class="k">class</span> <span class="nc">PersistedQuery</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
<span class="k">end</span>
</code></pre></div><div class=highlight><pre class="highlight ruby"><code><span class="c1"># db/migrate/20180617011135_create_persisted_queries.rb</span>
<span class="k">class</span> <span class="nc">CreatePersistedQueries</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.2</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:persisted_queries</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:signature</span><span class="p">,</span> <span class="ss">index: </span><span class="p">{</span> <span class="ss">unique: </span><span class="kp">true</span> <span class="p">}</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:query</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>We will store the persisted queries in this newly created table &ndash; notice that we have a unique index on the signature. Now let&rsquo;s add the required route and controller that will accept the synchronization request.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># config/routes.rb</span>
<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="c1"># ... existing routes</span>
  <span class="n">post</span> <span class="s2">"/graphql_persist"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"graphql_persist#execute"</span>
<span class="k">end</span>
</code></pre></div><div class=highlight><pre class="highlight ruby"><code><span class="c1"># app/controllers/graphql_persist_controller.rb</span>
<span class="k">class</span> <span class="nc">GraphqlPersistController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">execute</span>
    <span class="n">document</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:query</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">valid_query?</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
      <span class="n">persisted_query</span> <span class="o">=</span> <span class="no">PersistedQuery</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
        <span class="ss">signature: </span><span class="n">params</span><span class="p">[</span><span class="ss">:signature</span><span class="p">],</span>
        <span class="ss">query: </span><span class="n">params</span><span class="p">[</span><span class="ss">:query</span><span class="p">],</span>
      <span class="p">)</span>

      <span class="n">render</span> <span class="ss">json: </span><span class="n">persisted_query</span><span class="p">.</span><span class="nf">attributes</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="ss">json: </span><span class="p">{</span> <span class="ss">errors: </span><span class="vi">@errors</span> <span class="p">},</span> <span class="ss">status: </span><span class="mi">500</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="p">{</span> <span class="ss">errors: </span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="p">]</span> <span class="p">},</span> <span class="ss">status: </span><span class="mi">500</span>
  <span class="k">end</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">valid_query?</span><span class="p">(</span><span class="n">document</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Query</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RailsGraphqlSchema</span><span class="p">,</span> <span class="ss">document: </span><span class="n">document</span><span class="p">)</span>
    <span class="n">validator</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">StaticValidation</span><span class="o">::</span><span class="no">Validator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">schema: </span><span class="no">RailsGraphqlSchema</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">validator</span><span class="p">.</span><span class="nf">validate</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="ss">:errors</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]</span>

    <span class="vi">@errors</span> <span class="o">=</span> <span class="n">errors</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:message</span><span class="p">)</span>
    <span class="vi">@errors</span><span class="p">.</span><span class="nf">empty?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> <p>In this controller, we are parsing out the <em>query</em> and validating it against our schema. If the query is okay from a schema perspective, then we create a new <code>PersistedQuery</code> database record with the <code>query</code> and the <code>signature</code>. When we get to using the persisted queries, we can do a quick look up and pull the query to be used.</p> <p>We can now run the <code>persistgraphql-signature-sync</code> command:</p> <div class=highlight><pre class="highlight plaintext"><code>node index.js --input-path=../react-graphql/src --sync-endpoint=http://localhost:3000/graphql_persist
</code></pre></div> <p>This will attempt to synchronize each query to the server. It is not the prettiest, but the command will print out the server&rsquo;s response for each query.</p> <div class=highlight><pre class="highlight plaintext"><code>Synching persisted query a38e6d5349901b395334b5fd3b14e84a7ca7c4fc060a4089f2c23b5cf76f0f80
{ id: 1,
  signature: 'a38e6d5349901b395334b5fd3b14e84a7ca7c4fc060a4089f2c23b5cf76f0f80',
  query: 'query ConsolesByYear($afterYear: Int, $beforeYear: Int) {\n  consoles(afterYear: $afterYear, beforeYear: $beforeYear) {\n    ...ConsoleFieldsFragment\n    company {\n      name\n      __typename\n    }\n    __typename\n  }\n}\n\nfragment ConsoleFieldsFragment on Console {\n  name\n  releaseYear\n  __typename\n}\n',
  created_at: '2018-07-03T19:52:54.717Z',
  updated_at: '2018-07-03T19:52:54.717Z' }
</code></pre></div> <h1>Refactor Rails Server to use Persisted Queries</h1> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/802dcc0d9aef28b117f926d7638a4a2115d304e1">GitHub</a></p> </blockquote> <p>The finish line is near! Our Rails server has the queries persisted in the database. Now we just have to adjust our <code>GraphqlController</code> to pull the appropriate query when receiving the persisted query request from our React application.</p> <div class=highlight><pre class="highlight ruby"><code><span class="c1"># app/controllers/graphql_controller.rb</span>
<span class="k">class</span> <span class="nc">GraphqlController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">execute</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">ensure_hash</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:variables</span><span class="p">])</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:query</span><span class="p">]</span>
    <span class="n">operation_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:operationName</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">query</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">RailsGraphqlSchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="ss">variables: </span><span class="n">variables</span><span class="p">,</span> <span class="ss">operation_name: </span><span class="n">operation_name</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">signature</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="nf">dig</span><span class="p">(</span><span class="ss">:extensions</span><span class="p">,</span> <span class="ss">:persistedQuery</span><span class="p">,</span> <span class="ss">:sha256Hash</span><span class="p">)</span>
      <span class="n">persisted_query</span> <span class="o">=</span> <span class="no">PersistedQuery</span><span class="p">.</span><span class="nf">find_by!</span><span class="p">(</span><span class="ss">signature: </span><span class="n">signature</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">RailsGraphqlSchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">persisted_query</span><span class="p">.</span><span class="nf">query</span><span class="p">,</span> <span class="ss">variables: </span><span class="n">variables</span><span class="p">,</span> <span class="ss">operation_name: </span><span class="n">operation_name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">render</span> <span class="ss">json: </span><span class="n">result</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="p">{</span> <span class="ss">errors: </span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="c1"># ... rest of class</span>
<span class="k">end</span>
</code></pre></div> <p>Our controller&rsquo;s action now handles the situation when we don&rsquo;t have a query present, which is the case when we&rsquo;re using persisted queries. In this situation, we pull out the <code>sha256Hash</code> value from the parameters and look up the persisted query. We then execute the persisted query&rsquo;s query against the schema.</p> <p>In the event that we want to <em>lock down</em> the API to only use persisted queries, we can use a conditional like <code>Rails.env.production?</code> to gate the flow, allowing only the persisted queries through.</p> <h1>Reflection</h1> <p>In this post, we created a Rails server that exposes a GraphQL API. We used <a href="https://github.com/kevinjalbert/graphql-persisted-queries/tree/master/persistgraphql-signature-sync"><code>persistgraphql-signature-sync</code></a> to assist in synchronizing the queries from the React application (that we built in <a href="/graphql-persisted-queries-with-http-caching-part-2/">part two</a>) to our Rails server.</p> <p><strong>Note:</strong> there does exist a paid pro version of <code>graphql-ruby</code> called <a href="http://graphql.pro/">GraphQL::Pro</a>, which has its own support for <a href="http://graphql-ruby.org/operation_store/overview">persisted queries</a>. It is a great solution as it covers synchronization of queries, admin dashboard, and connection to clients (Apollo/Relay). If you can afford the cost and want an <em>off the shelf</em> solution, it is something you could consider. For the purpose of this article, however, we will skip out on it.</p> <p>In the next and last part of this series, we will look at the final goal of adding HTTP caching to our GraphQL API servers. With HTTP caching we can lessen the load on our servers and offer faster response times to the consumers of the API.</p> <blockquote> <p>This topic was presented at <a href="https://www.meetup.com/GraphQL-Toronto/events/251760335/">GraphQL Toronto July 2018</a>:</p> <ul> <li><a href="https://www.youtube.com/watch?v=ocX_jf81LwE">Watch the talk</a></li> <li><a href="https://speakerdeck.com/kevinjalbert/graphql-persisted-queries-with-http-caching">Read the slides</a></li> </ul> </blockquote> <div class=article__comments-button><button type=button class="btn btn-default show-comments">Click to Disqus</button></div> <div id=disqus_thread></div> </div> </div> </div> <script>
//<![CDATA[
    var disqus_shortname = 'kevinjalbert';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
//]]>
</script> </body> <div class="container footer"> <div class="col-md-12 footer__social"> <a href="https://twitter.com/KevinJalbert">Twitter</a> <a href="https://github.com/kevinjalbert">GitHub</a> <a href="https://stackoverflow.com/users/583592/kevin-jalbert">Stack Overflow</a> </div> <div class="col-md-12 footer__copywrite"> Code licensed <a href="https://github.com/kevinjalbert/kevinjalbert.github.io/blob/real-master/LICENSE">MIT</a>, Content &copy; 2019 Kevin Jalbert </div> </div> </html> <script src="/javascripts/app.js"></script>