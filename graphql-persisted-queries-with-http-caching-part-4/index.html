<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content='IE=edge;chrome=1'/> <meta name=viewport content="width=device-width, initial-scale=1"> <script>addEventListener('error', window.__e=function f(e){f.q=f.q||[];f.q.push(e)});</script> <link rel=canonical href=https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/> <title>GraphQL Persisted Queries with HTTP Caching [Part 4] | Kevin Jalbert</title> <meta name=description content="This is the last of four parts on GraphQL Persisted Queries with HTTP Caching. We end by adding HTTP caching to our Express, Rails and React applications."/> <meta name=keywords content="graphql, rails, express, http caching"/> <meta name=datePublished content="2018-07-18 00:00:00 UTC"/> <meta property="og:article:published_time" content="2018-07-18 00:00:00 UTC"/> <meta name=author content="Kevin Jalbert"/> <meta property="og:article:author" content="2018-07-18 00:00:00 UTC"/> <meta name=url content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/"/> <meta property="og:url" content="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/"/> <meta name=site content="Kevin Jalbert"/> <meta property="og:site_name" content="Kevin Jalbert"/> <meta name="twitter:card" content=summary_large_image /> <meta name="twitter:creator" content="@kevinjalbert"/> <meta name="twitter:description" content="This is the last of four parts on GraphQL Persisted Queries with HTTP Caching. We end by adding HTTP caching to our Express, Rails and React applications."/> <meta name="twitter:image:src" content="https://kevinjalbert.com/images/2018-07-18-graphql-persisted-queries-with-http-caching-part-4/post-query.png"/> <meta name="twitter:site" content="Kevin Jalbert"/> <meta name="twitter:title" content="GraphQL Persisted Queries with HTTP Caching [Part 4]"/> <meta property="og:description" content="This is the last of four parts on GraphQL Persisted Queries with HTTP Caching. We end by adding HTTP caching to our Express, Rails and React applications."/> <meta property="og:image" content="https://kevinjalbert.com/images/2018-07-18-graphql-persisted-queries-with-http-caching-part-4/post-query.png"/> <meta property="og:title" content="GraphQL Persisted Queries with HTTP Caching [Part 4]"/> <script type="application/ld+json">
    {
       "@context": "http://schema.org",
       "@type": "BlogPosting",
       "headline": "GraphQL Persisted Queries with HTTP Caching [Part 4]",
       "keywords": "graphql, rails, express, http caching",
       "url": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/",
       "datePublished": "2018-07-18 00:00:00 UTC",
       "dateModified": "2018-07-18 00:00:00 UTC",
       "author": {
         "@type": "Person",
         "name": "Kevin Jalbert",
         "sameAs": [
           "https://twitter.com/kevinjalbert",
           "https://github.com/kevinjalbert",
           "https://keybase.io/kevinjalbert",
           "https://reddit.com/user/kevinjalbert"
         ]
       },
       "mainEntityOfPage": {
          "@type": "WebPage",
         "@id": "https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/"
       }
    }
  </script> <link href="/stylesheets/app.css" rel=stylesheet /> <link rel=alternate type="application/atom+xml" title="Articles | Kevin Jalbert" href="/feed.xml"/> <script async src="/vendor/analytics/index.js"></script> <script async src="https://www.google-analytics.com/analytics.js"></script> </head> <div class=container> <div class=header> <div class="col-xs-12 col-sm-7 navigation"> <a class=banner href="/">Kevin Jalbert</a> <a href="/about/">About</a> <a href="/now/">Now</a> <a href="/uses/">Uses</a> <a href="https://github.com/kevinjalbert/ama/blob/master/README.md">AMA</a> </div> <div class="col-xs-12 col-sm-5 search-component"> <input placeholder=Search class="search ui-autocomplete-input ui-corner-all" autocomplete=on> </div> </div> </div> <body> <div class="container content article"> <div class=row> <div class=col-md-12> <h1 class=article__title><p>GraphQL Persisted Queries with HTTP Caching [Part 4]</p> </h1> <div class="row article__meta-info"> <div class="col-xs-4 col-md-4"> <div class="article__date entry-date">July 18, 2018 </div> </div> <div class="col-xs-4 col-md-4"> <div class=article__read-time>6 min read</div> </div> <div class="col-xs-4 col-md-4"> <div class=article__comments> <a href="https://kevinjalbert.com/graphql-persisted-queries-with-http-caching-part-4/#disqus_thread">0 Comments</a> </div> </div> </div> <div class="row article__meta-tags"> <div class="col-xs-12 col-md-12"> <div class=article__tags> <a href="/tags/express/">express</a> <a href="/tags/graphql/">graphql</a> <a href="/tags/http-caching/">http caching</a> <a href="/tags/rails/">rails</a> </div> </div> </div> <img src=/images/2018-07-18-graphql-persisted-queries-with-http-caching-part-4/post-query.png> <i><p>Generated with <a href="https://carbon.now.sh/">Carbon.now.sh</a></p> </i> <div class=article__separator></div> <div class=newsletter__form> <div class="panel panel-default"> <div class=panel-heading> <h4 class="panel-title accordion-toggle collapsed" data-toggle=collapse data-parent="#accordion" href="#newsletterFormCollapse"> If you enjoy this, consider subscribing to my newsletter </h4> </div> <div id=newsletterFormCollapse class="panel-collapse collapse"> <div class=panel-body> <p style="text-align: center">I aim to publish one article a month</p> <link href="//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css" rel=stylesheet> <style>
              #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; width:100%;}
              /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.
                 We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */
        </style> <div id=mc_embed_signup> <form action="//kevinjalbert.us14.list-manage.com/subscribe/post?u=fe02783eec556cfc2893fe174&amp;id=aecd14f8e6" method=post id=mc-embedded-subscribe-form name=mc-embedded-subscribe-form class=validate target=_blank novalidate> <div id=mc_embed_signup_scroll> <input type=email value="" name=EMAIL class=email id=mce-EMAIL placeholder="E-mail address" required> <div style="position: absolute; left: -5000px;" aria-hidden=true><input name=b_fe02783eec556cfc2893fe174_aecd14f8e6 tabindex=-1 value=""></div> <div class=clear><input type=submit value=Subscribe name=subscribe id=mc-embedded-subscribe class=button></div> </div> </form> </div> </div> </div> </div> </div> <p>This is the last part of a four-part series on GraphQL Persisted Queries with HTTP Caching. As a recap of <a href="/graphql-persisted-queries-with-http-caching-part-3/">part three</a>, we created a Rails application capable of handling persisted queries.</p> <p>In part four we will cover the following topics:</p> <ol> <li>Add HTTP Caching to React Application</li> <li>Add HTTP Caching to Express Server</li> <li>Add HTTP Caching to Rails Server</li> <li>Alternative Caching with Gateways</li> </ol> <h1>Caching with GraphQL</h1> <p>There are different ways to <em>cache</em> with GraphQL:</p> <ul> <li><a href="https://www.apollographql.com/docs/react/advanced/caching.html">Caching on the Apollo client</a>.</li> <li><a href="http://mgiroux.me/2016/graphql-query-caching-with-rails/">Caching the parsed and validated GraphQL query</a>.</li> <li><a href="https://github.com/chatterbugapp/cacheql">Caching field and response resolutions</a>.</li> <li>Amongst other mechanisms and techniques.</li> </ul> <p>For our situation, we&rsquo;re interested in HTTP caching, and the way to achieve this is to make our GraphQL network requests use <code>GET</code> instead of <code>POST</code>.</p> <p>The main benefit for HTTP caching is that it allows CDNs and reverse proxy&rsquo;s (i.e., <a href="https://varnish-cache.org/">Varnish</a>) to cache intermediate responses based on the response&rsquo;s headers (i.e., <code>Cache-Control</code>). This results in fewer requests hitting your server as the results might be cached, perfect for scaling your API. Even a short cache (i,e., &lt; 10 seconds) could be extremely valuable as this cache could be shared across all consumers of the API.</p> <p>I want to bring up an article by <a href="https://twitter.com/_CoreyClark">Corey Clark</a> which tackles a very similar problem on how to use <a href="https://medium.com/@coreyclark/graphql-persisted-queries-using-get-requests-8a6704aba9eb"><code>GET</code> requests with GraphQL Persisted Queries</a>. Both the current post and Corey&rsquo;s article reach a similar state in achieving HTTP cacheability using <code>GET</code> requests.</p> <p>In the following sections, we will augment our Express and Rails servers as well as our React application to use <code>GET</code> requests. To simplify things, we&rsquo;re going to apply a simple 10-second cache on all our responses (ideally you could tailor this to the individual query). In addition, we&rsquo;re going to make an assumption that we don&rsquo;t have any personalized data in our query responses.</p> <h2>Add HTTP Caching to React Application</h2> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/5cbb630c4780d20bc2747b0b62035a3702e87a3b">GitHub</a></p> </blockquote> <p>Fortunately, the <code>apollo-link-persisted-queries</code> link has a simple option (<code>useGETForHashedQueries</code>) to enable <code>GET</code> requests for queries (but not mutations):</p> <div class=highlight><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ApolloClient</span><span class="p">({</span>
  <span class="na">link</span><span class="p">:</span> <span class="nx">createPersistedQueryLink</span><span class="p">({</span> <span class="na">useGETForHashedQueries</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}).</span><span class="nx">concat</span><span class="p">(</span>
    <span class="nx">createHttpLink</span><span class="p">({</span> <span class="na">uri</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:5000/graphql</span><span class="dl">'</span> <span class="p">})</span>
  <span class="p">),</span>
  <span class="na">cache</span><span class="p">:</span> <span class="k">new</span> <span class="nx">InMemoryCache</span><span class="p">(),</span>
<span class="p">});</span>
</code></pre></div> <p>Now the outbound requests look like the following (a bit messy, but gets the job done):</p> <div class=highlight><pre class="highlight plaintext"><code>http://localhost:5000/graphql?operationName=ConsolesByYear&amp;variables=%7B%22afterYear%22%3A1990%2C%22beforeYear%22%3A2000%7D&amp;extensions=%7B%22persistedQuery%22%3A%7B%22version%22%3A1%2C%22sha256Hash%22%3A%22a38e6d5349901b395334b5fd3b14e84a7ca7c4fc060a4089f2c23b5cf76f0f80%22%7D%7D
</code></pre></div> <p>To better see the requests being cached on the HTTP layer, we&rsquo;re going to modify the <code>Query</code> in our <code>ConsoleContainer</code>:</p> <div class=highlight><pre class="highlight jsx"><code><span class="o">&lt;</span><span class="nx">Query</span> <span class="nx">query</span><span class="o">=</span><span class="p">{</span><span class="nx">QUERY</span><span class="p">}</span> <span class="nx">variables</span><span class="o">=</span><span class="p">{{</span> <span class="nx">afterYear</span><span class="p">,</span> <span class="nx">beforeYear</span> <span class="p">}}</span> <span class="nx">fetchPolicy</span><span class="o">=</span><span class="dl">'</span><span class="s1">network-only</span><span class="dl">'</span><span class="o">&gt;</span>
</code></pre></div> <p>By adding <code>fetchPolicy</code> of <code>network-only</code> the <code>apollo-client</code> will not cache responses, and thus each query will be sent to the GraphQL API.</p> <h2>Add HTTP Caching to Express Server</h2> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/0bf8d6bccc5649b00dda77b4dfdce523c22b4796">GitHub</a></p> </blockquote> <p>We have to do a couple things to get our Express server in shape to serve <code>GET</code> requests. First thing is to remove the <code>bodyParser</code> middleware as we aren&rsquo;t parsing a <code>POST</code> anymore. We will also adjust our <code>GraphQLServer</code> options to toggle the <code>getEndpoint</code>, which adds a <code>GET</code> endpoint using our defined GraphQL route. Finally, we have to modify our <code>persistedQueriesMiddleware</code> to be on the <code>GET</code> route for <code>/graphql</code>. Those changes looks like the following:</p> <div class=highlight><pre class="highlight javascript"><code><span class="c1">// server.js</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">GraphQLServer</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">graphql-yoga</span><span class="dl">'</span><span class="p">)</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nx">typeDefs</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./graphql/typeDefs</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">resolvers</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./graphql/resolvers</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">persistedQueriesMiddleware</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./persistedQueriesMiddleware</span><span class="dl">'</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLServer</span><span class="p">({</span> <span class="nx">typeDefs</span><span class="p">,</span> <span class="nx">resolvers</span> <span class="p">})</span>
<span class="kd">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">port</span><span class="p">:</span> <span class="mi">5000</span><span class="p">,</span>
  <span class="na">getEndpoint</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="na">endpoint</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/graphql</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">playground</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/playground</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">express</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/graphql</span><span class="dl">'</span><span class="p">,</span> <span class="nx">persistedQueriesMiddleware</span><span class="p">)</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">start</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span> <span class="p">({</span> <span class="nx">port</span> <span class="p">})</span> <span class="o">=&gt;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="s2">`Server started, listening on port </span><span class="p">${</span><span class="nx">port</span><span class="p">}</span><span class="s2"> for incoming requests.`</span><span class="p">,</span>
  <span class="p">),</span>
<span class="p">)</span>
</code></pre></div> <p>We also have to modify our <code>persistedQueriesMiddleware</code> itself to parse the <code>GET</code> query parameters and specify the response&rsquo;s <code>Cache-Control</code> header for a <code>max-age</code> of 10 seconds:</p> <div class=highlight><pre class="highlight javascript"><code><span class="c1">// persistedQueriesMiddleware.js</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">invert</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">lodash</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">extractedQueries</span> <span class="o">=</span> <span class="nx">invert</span><span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./extracted_queries.json</span><span class="dl">'</span><span class="p">))</span>

<span class="nx">persistedQueriesMiddleware</span> <span class="o">=</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Handling request to: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">req</span><span class="p">.</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">res</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">Cache-Control</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">public, max-age=10</span><span class="dl">'</span><span class="p">)</span>

  <span class="kd">const</span> <span class="nx">extensions</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">extensions</span><span class="p">)</span>
  <span class="kd">const</span> <span class="nx">querySignature</span> <span class="o">=</span> <span class="nx">extensions</span><span class="p">.</span><span class="nx">persistedQuery</span><span class="p">.</span><span class="nx">sha256Hash</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">persistedQuery</span> <span class="o">=</span> <span class="nx">extractedQueries</span><span class="p">[</span><span class="nx">querySignature</span><span class="p">]</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">persistedQuery</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">400</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="na">errors</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">Invalid querySignature</span><span class="dl">'</span><span class="p">]</span> <span class="p">})</span>
    <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Invalid querySignature</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">}</span>

  <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">query</span> <span class="o">=</span> <span class="nx">persistedQuery</span>
  <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">persistedQueriesMiddleware</span> <span class="p">}</span>
</code></pre></div> <h2>Add HTTP Caching to Rails Server</h2> <blockquote> <p>Follow along with the complete code changes on <a href="https://github.com/kevinjalbert/graphql-persisted-queries/commit/c3bcc3588012a9b4b22bd582c80de3e0dd208078">GitHub</a></p> </blockquote> <p>For our Rails server, we have a few small changes to make to allow for <code>GET</code> requests. First, we&rsquo;ll add a new route to allow for <code>GET</code> requests, under the same URL and controller action:</p> <div class=highlight><pre class="highlight ruby"><code><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">routes</span><span class="p">.</span><span class="nf">draw</span> <span class="k">do</span>
  <span class="c1"># .. other routes</span>
  <span class="n">post</span> <span class="s2">"/graphql"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"graphql#execute"</span>
  <span class="n">get</span> <span class="s2">"/graphql"</span><span class="p">,</span> <span class="ss">to: </span><span class="s2">"graphql#execute"</span>
<span class="k">end</span>
</code></pre></div> <p>Like before, we handle the persisted queries within the <code>GraphqlController</code>. We need to tweak the controller to conform to the new query parameters structure of the React application&rsquo;s requests. We will also add an <code>expires_in</code> to add in the 10-seconds of <code>max-age</code> for the response&rsquo;s <code>Cache-Control</code> header:</p> <div class=highlight><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">GraphqlController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">execute</span>
    <span class="n">expires_in</span><span class="p">(</span><span class="mi">10</span><span class="p">.</span><span class="nf">seconds</span><span class="p">,</span> <span class="ss">public: </span><span class="kp">true</span><span class="p">)</span>

    <span class="n">variables</span> <span class="o">=</span> <span class="n">ensure_hash</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:variables</span><span class="p">])</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:query</span><span class="p">]</span>
    <span class="n">operation_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:operationName</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">query</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">RailsGraphqlSchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="ss">variables: </span><span class="n">variables</span><span class="p">,</span> <span class="ss">operation_name: </span><span class="n">operation_name</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">extensions</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:extensions</span><span class="p">])</span> <span class="o">||</span> <span class="p">{}</span>
      <span class="n">signature</span> <span class="o">=</span> <span class="n">extensions</span><span class="p">.</span><span class="nf">dig</span><span class="p">(</span><span class="s2">"persistedQuery"</span><span class="p">,</span> <span class="s2">"sha256Hash"</span><span class="p">)</span>
      <span class="n">persisted_query</span> <span class="o">=</span> <span class="no">PersistedQuery</span><span class="p">.</span><span class="nf">find_by!</span><span class="p">(</span><span class="ss">signature: </span><span class="n">signature</span><span class="p">)</span>
      <span class="n">result</span> <span class="o">=</span> <span class="no">RailsGraphqlSchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">persisted_query</span><span class="p">.</span><span class="nf">query</span><span class="p">,</span> <span class="ss">variables: </span><span class="n">variables</span><span class="p">,</span> <span class="ss">operation_name: </span><span class="n">operation_name</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">render</span> <span class="ss">json: </span><span class="n">result</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="n">render</span> <span class="ss">json: </span><span class="p">{</span> <span class="ss">errors: </span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="p">]</span> <span class="p">}</span>
  <span class="k">end</span>
</code></pre></div> <h2>Alternative Caching with Gateways</h2> <p>I didn&rsquo;t mention <a href="https://www.apollographql.com/engine">Apollo Engine</a>, but this is a recent development in the GraphQL caching space. It provides a layer which sits in front of your GraphQL server and handles caching, query execution tracing, and error tracking. It is a paid solution if you need to handle more than 1 million requests per month.</p> <p>Part of the secret sauce for caching with Apollo Engine is that it introduced the <a href="https://github.com/apollographql/apollo-cache-control">Apollo Cache Control</a> GraphQL extension. This allows the GraphQL API to return cache hints on a per field-level. Effectively, this allows the caching to be smarter than simply a blanket solution.</p> <p>For additional reading on these technologies and techniques, I recommend the following article on <a href="https://dev-blog.apollodata.com/caching-graphql-results-in-your-cdn-54299832b8e2">Caching GraphQL Results in your CDN</a> as it uses Automatic Persisted Queries, Apollo Cache Control, and Apollo Engine.</p> <p>Another paid solution (if you exceed 5,000 requests per months) is <a href="https://fastql.io/">FastQL</a>. This is a new gateway solution which acts as its own CDN, handling caching and expiration of fields. You are able to manually invalidate field-level caches through an API, or automatically invalidate by sending mutations through their CDN (which expires fields related to the mutation object type).</p> <h1>Reflection</h1> <p>There are a lot of options available for caching with GraphQL. It is possible to do so at different layers of the flow using different techniques and technologies. In this last post of the series we mainly took a look at HTTP caching. By enabling <code>GET</code> requests we were half-way there &ndash; the last bit remaining is attaching the appropriate <code>Cache-Control</code> headers. Admittedly, we took an easy approach of blanketing all responses with a 10 second <code>max-age</code>.</p> <p>Depending on your situation, you might need to further explore the field-level caching options like Apollo Cache Control, or even using a Gateway to help out, like FastQL. Even though being aware of the data within your queries is important, is it all cacheable? If you have personalized data you have to approach this in a different way. There might not be value in caching if every response is personalized to a user, or maybe you have to split your queries into two queries (i.e., personalized, non-personalized). The cache configuration (i.e., CDN and/or a reverse proxy) is a huge piece we skipped over, but it likely will need some tweaking for your specific use cases (i.e., split caching based on the header).</p> <p>Overall, I am pleased with the solutions we arrived too. We built a simple GraphQL API in Express and Rails. Both of these can communicate with a React application using persisted queries. Our Express server used a JSON file for its data and persisted queries, while for our Rails server we had everything in a database. We overcame the issues with the existing tooling for determining a signature for each query, and created the ability to synchronize persisted queries via HTTP <code>POST</code> requests. We were able to implement <code>GET</code> requests and apply a 10-second cache for intermediate CDN and reverse proxies.</p> <blockquote> <p>This topic was presented at <a href="https://www.meetup.com/GraphQL-Toronto/events/251760335/">GraphQL Toronto July 2018</a>:</p> <ul> <li><a href="https://www.youtube.com/watch?v=ocX_jf81LwE">Watch the talk</a></li> <li><a href="https://speakerdeck.com/kevinjalbert/graphql-persisted-queries-with-http-caching">Read the slides</a></li> </ul> </blockquote> <div class=article__comments-button><button type=button class="btn btn-default show-comments">Click to Disqus</button></div> <div id=disqus_thread></div> </div> </div> </div> <script>
//<![CDATA[
    var disqus_shortname = 'kevinjalbert';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
//]]>
</script> </body> <div class="container footer"> <div class="col-md-12 footer__social"> <a href="https://twitter.com/KevinJalbert">Twitter</a> <a href="https://github.com/kevinjalbert">GitHub</a> <a href="https://stackoverflow.com/users/583592/kevin-jalbert">Stack Overflow</a> </div> <div class="col-md-12 footer__copywrite"> Code licensed <a href="https://github.com/kevinjalbert/kevinjalbert.github.io/blob/real-master/LICENSE">MIT</a>, Content &copy; 2019 Kevin Jalbert </div> </div> </html> <script src="/javascripts/app.js"></script>